[{"content":" 什么是Clark变换？ Clark变换将三相系统（在 abc 坐标系中）的时域分量转换为正交静止坐标系 (αβ) 中的两个分量。\n利用基变换来实现三相坐标系(abc)到两相正交坐标系(αβ) 已知三相坐标系的相位依次相差120°且αβ为正交坐标系。 将α轴与a轴重叠，将向量a沿着原点O的方向延长做一条辅助线，∠boe和∠coe等于60°。\n计算向量b和向量c到α轴的投影长度： $$ be = \\sin(∠boe) = \\sin(60°) = \\frac{\\sqrt{3}}{2} \\\\ ce = -\\sin(∠coe) = -\\sin(60°) = -\\frac{\\sqrt{3}}{2} $$ 因为向量c在α轴的下方所以投影为负\n计算向量b和向量c到β轴的投影长度： $$ bg = -\\cos(∠boe) = -\\cos(60°) = -\\frac{1}{2} \\\\ ch = -\\cos(∠coe) = -\\cos(60°) = -\\frac{1}{2} $$ 因为向量b和向量c在β轴的左侧所以投影为负\n组合出基变换矩阵 根据上面的投影可以得到a,b,c三个向量的坐标：向量 $a=[1, 0]$，向量$b=[-\\frac{1}{2},\\frac{\\sqrt{3}}{2}] $，向量 $c=[-\\frac{1}{2},-\\frac{\\sqrt{3}}{2}] $\n所以基变换矩阵为：\n$$ A = \\left[ \\begin{matrix} 1 \u0026 -\\frac{1}{2} \u0026 -\\frac{1}{2} \\\\ 0 \u0026 \\frac{\\sqrt{3}}{2}\u0026 -\\frac{\\sqrt{3}}{2} \\end{matrix} \\right] $$ 坐标转换公式为：\n$$ \\left[ \\begin{matrix} i\\alpha \\\\ i\\beta \\end{matrix} \\right] = \\left[ \\begin{matrix} 1 \u0026 -\\frac{1}{2} \u0026 -\\frac{1}{2} \\\\ 0 \u0026 \\frac{\\sqrt{3}}{2}\u0026 -\\frac{\\sqrt{3}}{2} \\end{matrix} \\right] \\left[ \\begin{matrix} ia \\\\ ib \\\\ ic \\end{matrix} \\right] $$ $$ i\\alpha = ia - \\frac{1}{2}ib - \\frac{1}{2}ic \\\\ i\\beta = \\frac{\\sqrt{3}}{2}ib - \\frac{\\sqrt{3}}{2}ic $$ 基尔霍夫电流定律： 所有进入某个节点的电流的总和等于所有离开这个节点的电流的总和。假设进入某节点的电流为正值，离开这个节点的电流为负值，则所有设计这个节点的电流的代数和等于零。\n$ \\sum_{k=1}^{n}(ik)=0 $\n所以：ia + ib + ic = 0，ic = -(ia+ib)\n使用ia和ib将公式中的ic消除后的公式： $$ i\\alpha = ia - \\frac{1}{2}ib + \\frac{1}{2}(ia+ib)\\\\ = ia - \\frac{1}{2}ib + \\frac{1}{2}ia+\\frac{1}{2}ib\\\\ =\\frac{3}{2}ia $$ $$ i\\beta = \\frac{\\sqrt{3}}{2}ib + \\frac{\\sqrt{3}}{2}(ia+ib)\\\\ = \\frac{\\sqrt{3}}{2}(ia+2\\times ib) $$ 等幅值变换 因为：$i\\alpha = \\frac{3}{2}ia$，所以需要在基变换后乘以$\\frac{2}{3}$使得$i\\alpha = ia$，$i\\beta = \\frac{\\sqrt{3}}{3}(ia+2\\times ib) $\n对应的基变换矩阵为：\n$$ \\left[ \\begin{matrix} i\\alpha \\\\ i\\beta \\end{matrix} \\right] =\\frac{2}{3} \\left[ \\begin{matrix} 1 \u0026 -\\frac{1}{2} \u0026 -\\frac{1}{2} \\\\ 0 \u0026 \\frac{\\sqrt{3}}{2}\u0026 -\\frac{\\sqrt{3}}{2} \\end{matrix} \\right] \\left[ \\begin{matrix} ia \\\\ ib \\\\ ic \\end{matrix} \\right] $$ 测试 为标准三相电压Ua、Ub、Uc在空间上互差120°，Vm为相电压峰值, $\\theta$为电角度：\n$$ Ua = Vm\\times \\cos(\\theta)\\\\ Ub = Vm\\times \\cos(\\theta+\\frac{2\\pi}{3})\\\\ Uc = Vm\\times \\cos(\\theta-\\frac{2\\pi}{3}) $$ 导入包:\nimport numpy as np import matplotlib.pyplot as plt %matplotlib inline 三相逆变输出的三相电压波形：\nplt.figure(figsize=(10, 3)) def U(m, e): return (m * np.cos(e), m * np.cos(e + 2 * np.pi / 3), m * np.cos(e - 2 * np.pi / 3)) e = np.arange(0, 20, 0.1) m = 1 (a, b, c) = U(m, e) plt.plot(e, a, label=\u0026#34;a\u0026#34;) plt.plot(e, b, label=\u0026#34;b\u0026#34;) plt.plot(e, c, label=\u0026#34;c\u0026#34;) plt.xlabel=\u0026#34;x\u0026#34; plt.ylabel=\u0026#34;y\u0026#34; plt.title(\u0026#39;\u0026#39;) plt.legend() plt.show() 经过Clark变换后的波形:\nplt.figure(figsize=(10, 3)) def U(m, e): return (m * np.cos(e), m * np.cos(e + 2 * np.pi / 3), m * np.cos(e - 2 * np.pi / 3)) def A(a, b, c): return (2/3)*(np.mat([[1, -1/2, -1/2], [0, np.sqrt(3)/2, -np.sqrt(3)/2]]) * np.mat([a, b, c])) e = np.arange(0, 20, 0.1) m = 1 (a, b, c) = U(m, e) d = A(a,b,c) plt.plot(e, d[0].tolist()[0], label=\u0026#34;alpha\u0026#34;) plt.plot(e, d[1].tolist()[0], label=\u0026#34;beta\u0026#34;) plt.xlabel=\u0026#34;x\u0026#34; plt.ylabel=\u0026#34;y\u0026#34; plt.title(\u0026#39;Clark\u0026#39;) plt.legend() plt.show() 如果将Clark变换中的系数$\\frac{2}{3}$去掉后会发现幅值和三相逆变输出的三相电压波形是不一样的，幅度多了1.5倍：\n","permalink":"https://fake-rick.github.io/posts/clark%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/","summary":"什么是Clark变换？ Clark变换将三相系统（在 abc 坐标系中）的时域分量转换为正交静止坐标系 (αβ) 中的两个分量。\n利用基变换来实现三相坐标系(abc)到两相正交坐标系(αβ) 已知三相坐标系的相位依次相差120°且αβ为正交坐标系。 将α轴与a轴重叠，将向量a沿着原点O的方向延长做一条辅助线，∠boe和∠coe等于60°。\n计算向量b和向量c到α轴的投影长度： $$ be = \\sin(∠boe) = \\sin(60°) = \\frac{\\sqrt{3}}{2} \\\\ ce = -\\sin(∠coe) = -\\sin(60°) = -\\frac{\\sqrt{3}}{2} $$ 因为向量c在α轴的下方所以投影为负\n计算向量b和向量c到β轴的投影长度： $$ bg = -\\cos(∠boe) = -\\cos(60°) = -\\frac{1}{2} \\\\ ch = -\\cos(∠coe) = -\\cos(60°) = -\\frac{1}{2} $$ 因为向量b和向量c在β轴的左侧所以投影为负\n组合出基变换矩阵 根据上面的投影可以得到a,b,c三个向量的坐标：向量 $a=[1, 0]$，向量$b=[-\\frac{1}{2},\\frac{\\sqrt{3}}{2}] $，向量 $c=[-\\frac{1}{2},-\\frac{\\sqrt{3}}{2}] $\n所以基变换矩阵为：\n$$ A = \\left[ \\begin{matrix} 1 \u0026 -\\frac{1}{2} \u0026 -\\frac{1}{2} \\\\ 0 \u0026 \\frac{\\sqrt{3}}{2}\u0026 -\\frac{\\sqrt{3}}{2} \\end{matrix} \\right] $$ 坐标转换公式为：","title":"Clark变换矩阵"},{"content":"QTcpSocket能够检测到Socket的连接与断开状态，并触发相关信号，我们只需要关联信号与槽就能够知道连接状态。\nconnect(\u0026amp;m_socket, \u0026amp;QTcpSocket::connected, this, \u0026amp;TcpClient::onConnected, Qt::QueuedConnection); connect(\u0026amp;m_socket, \u0026amp;QTcpSocket::disconnected, this, \u0026amp;TcpClient::onDisconnected, Qt::QueuedConnection); 还有一些特殊情况是无法触发QTcpSocket::disconnected信号，比如说：网线突然拔了、对端设备突然爆掉了等。这类情况由于对端socket未正常调用close()方法而导致的。\n我们可以定义一个心跳包去定期检查对端的存活状态，这种做法在协议还未指定的初期是比较适合的，客户端与服务端制定一套心跳请求与应答机制来判断对端的存活状态。但是往往下位机的程序已经存在（开发者不愿意修改或增加现有协议），这时候如何能够在特殊情况下检测到网络断开呢？\n主角登场：Keepalive机制\nkeepalive简介（摘自维基百科） 传输控制协议（TCP）存活包为可选特性，且默认关闭。存活包内没有数据。在以太网网络中，存活包的大小为最小长度的几帧（64字节）。协议中，还有三个与存活包相关的参数：\n存活时长（英语：Keepalive time）即空闲时，两次传输存活包的持续时间。TCP存活包时长可手动配置，默认不少于2个小时。 存活间隔（英语：Keepalive interval）即未收到上个存活包时，两次连续传输存活包的时间间隔。 存活重试次数（英语：Keepalive retry）即在判断远程主机不可用前的发送存活包次数。当两个主机透过TCP/IP协议相连时，TCP存活包可用于判断连接是否可用，并按需中断。 多数支持TCP协议的主机也同时支持TCP存活包。每个主机按一定周期向其他主机发送TCP包来请求回应。若发送主机未收到特定主机的回应（ACK），则将从发送主机一侧中断连接。 若其他主机在连接关闭后发送TCP存活包，关闭连接的一方将发送RST包来表明旧连接已不可用。其他主机将关闭它一侧的连接以新建连接。 空闲的TCP连接通常会隔每45秒或60秒发送一次存活包。在未连续收到三次ACK包时，连接将中断。此行为因主机而异，如默认情况下的Windows主机将在7200000ms（2小时）后发送首个存活包，随后再以1000ms的间隔发送5个存活包。若任意存活包未收到回应，连接将被中断。\nQt开启Keepalive（Linux与Windows） #include \u0026#34;keepalive.h\u0026#34; #include \u0026lt;QObject\u0026gt; const int keepalive = 1; // 开启keepalive属性 const int keepidle = 5; // 如果连接在5秒内没有任何数据来往则进行探测 const int keepinterval = 3; // 探测时发包的时间间隔为3秒 const int keepcount = 3; // 尝试探测的次数， 如果第一次探测包就收到响应，则不在继续探测 #if defined (Q_OS_LINUX) || defined (Q_OS_MACOS) #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;netinet/tcp.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; // 开启TCP心跳检测机制 int enableKeepalive(int fd) { if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, \u0026amp;keepalive, sizeof(keepalive)) \u0026lt; 0) return -1; if (setsockopt(fd, SOL_TCP, TCP_KEEPIDLE, \u0026amp;keepidle, sizeof(keepidle)) \u0026lt; 0) return -1; if (setsockopt(fd, SOL_TCP, TCP_KEEPINTVL, \u0026amp;keepinterval, sizeof(keepinterval)) \u0026lt; 0) return -1; if (setsockopt(fd, SOL_TCP, TCP_KEEPCNT, \u0026amp;keepcount, sizeof(keepcount)) \u0026lt; 0) return -1; return 0; } #elif defined (Q_OS_WIN) #include \u0026lt;winsock2.h\u0026gt; #define SIO_KEEPALIVE_VALS _WSAIOW(IOC_VENDOR,4) struct tcp_keepalive { unsigned long onoff; unsigned long keepalivetime; unsigned long keepaliveinterval; }; int enableKeepalive(int fd) { if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (char*)\u0026amp;keepalive, sizeof(keepalive)) \u0026lt; 0) return -1; struct tcp_keepalive in_keep_alive; memset(\u0026amp;in_keep_alive, 0, sizeof(in_keep_alive)); unsigned long ul_in_len = sizeof(struct tcp_keepalive); struct tcp_keepalive out_keep_alive; memset(\u0026amp;out_keep_alive, 0, sizeof(out_keep_alive)); unsigned long ul_out_len = sizeof(struct tcp_keepalive); unsigned long ul_bytes_return = 0; in_keep_alive.onoff = 1; // 打开keepalive in_keep_alive.keepaliveinterval = keepinterval * 1000; // 发送keepalive心跳时间间隔-单位为毫秒 in_keep_alive.keepalivetime = keepidle * 1000; // 多长时间没有报文开始发送keepalive心跳包-单位为毫秒 if (WSAIoctl(fd, SIO_KEEPALIVE_VALS, (LPVOID)\u0026amp;in_keep_alive, ul_in_len, (LPVOID)\u0026amp;out_keep_alive, ul_out_len, \u0026amp;ul_bytes_return, NULL, NULL) \u0026lt; 0) return -1; return 0; } #else int enableKeepalive(int fd) { Q_UNUSED(fd); return -1; } #endif Socket文件描述符的获取 QAbstractSocket::socketDescriptor() ，在socket连接成功后可使通过m_socket-\u0026gt;socketDescriptor();获取到QTcpSocket的文件描述符（FD）,失败时返回-1，这边获取到的fd可以提供给int enableKeepalive(int fd);作为参数用于启用keepalive。\n文档介绍：\nReturns the native socket descriptor of the QAbstractSocket object if this is available; otherwise returns -1.\nIf the socket is using QNetworkProxy, the returned descriptor may not be usable with native socket functions.\nThe socket descriptor is not available when QAbstractSocket is in UnconnectedState.\n断线重连 在开启keepalive后我们就可以在链路断开时触发QTcpSocket::disconnected信号了，这时候我们只需要开启一个定时器去试试检查QTcpSocket的状态，当状态为QAbstractSocket::UnconnectedState时清理QTcpSocket资源并尝试重新与服务端建立连接即可。\n// 状态检查定时器槽函数 void TcpClient::onCheckState() { switch (m_socket.state()) { case QAbstractSocket::UnconnectedState: m_socket.close(); m_socket.abort(); m_socket.connectToHost(m_remoteIp, m_remotePort); break; case QAbstractSocket::HostLookupState: break; case QAbstractSocket::ConnectingState: break; case QAbstractSocket::ConnectedState: break; case QAbstractSocket::BoundState: break; case QAbstractSocket::ListeningState: break; case QAbstractSocket::ClosingState: break; } } ","permalink":"https://fake-rick.github.io/posts/qt%E4%BD%BF%E7%94%A8keepalive%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E6%96%AD%E7%BA%BF%E9%87%8D%E8%BF%9E/","summary":"QTcpSocket能够检测到Socket的连接与断开状态，并触发相关信号，我们只需要关联信号与槽就能够知道连接状态。\nconnect(\u0026amp;m_socket, \u0026amp;QTcpSocket::connected, this, \u0026amp;TcpClient::onConnected, Qt::QueuedConnection); connect(\u0026amp;m_socket, \u0026amp;QTcpSocket::disconnected, this, \u0026amp;TcpClient::onDisconnected, Qt::QueuedConnection); 还有一些特殊情况是无法触发QTcpSocket::disconnected信号，比如说：网线突然拔了、对端设备突然爆掉了等。这类情况由于对端socket未正常调用close()方法而导致的。\n我们可以定义一个心跳包去定期检查对端的存活状态，这种做法在协议还未指定的初期是比较适合的，客户端与服务端制定一套心跳请求与应答机制来判断对端的存活状态。但是往往下位机的程序已经存在（开发者不愿意修改或增加现有协议），这时候如何能够在特殊情况下检测到网络断开呢？\n主角登场：Keepalive机制\nkeepalive简介（摘自维基百科） 传输控制协议（TCP）存活包为可选特性，且默认关闭。存活包内没有数据。在以太网网络中，存活包的大小为最小长度的几帧（64字节）。协议中，还有三个与存活包相关的参数：\n存活时长（英语：Keepalive time）即空闲时，两次传输存活包的持续时间。TCP存活包时长可手动配置，默认不少于2个小时。 存活间隔（英语：Keepalive interval）即未收到上个存活包时，两次连续传输存活包的时间间隔。 存活重试次数（英语：Keepalive retry）即在判断远程主机不可用前的发送存活包次数。当两个主机透过TCP/IP协议相连时，TCP存活包可用于判断连接是否可用，并按需中断。 多数支持TCP协议的主机也同时支持TCP存活包。每个主机按一定周期向其他主机发送TCP包来请求回应。若发送主机未收到特定主机的回应（ACK），则将从发送主机一侧中断连接。 若其他主机在连接关闭后发送TCP存活包，关闭连接的一方将发送RST包来表明旧连接已不可用。其他主机将关闭它一侧的连接以新建连接。 空闲的TCP连接通常会隔每45秒或60秒发送一次存活包。在未连续收到三次ACK包时，连接将中断。此行为因主机而异，如默认情况下的Windows主机将在7200000ms（2小时）后发送首个存活包，随后再以1000ms的间隔发送5个存活包。若任意存活包未收到回应，连接将被中断。\nQt开启Keepalive（Linux与Windows） #include \u0026#34;keepalive.h\u0026#34; #include \u0026lt;QObject\u0026gt; const int keepalive = 1; // 开启keepalive属性 const int keepidle = 5; // 如果连接在5秒内没有任何数据来往则进行探测 const int keepinterval = 3; // 探测时发包的时间间隔为3秒 const int keepcount = 3; // 尝试探测的次数， 如果第一次探测包就收到响应，则不在继续探测 #if defined (Q_OS_LINUX) || defined (Q_OS_MACOS) #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;netinet/tcp.","title":"Qt使用Keepalive机制实现断线重连"}]